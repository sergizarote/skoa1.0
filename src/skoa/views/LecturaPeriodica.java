/**                   
 * 
 GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
 */
package skoa.views;

// Obtenidos de "Dialog_Read_Periodica.java"
// Estos parece ser que no son necesarios
//import tuwien.auto.eicldemo.ui.*;
//import javax.swing.JComboBox;
//import javax.swing.JButton;
//import javax.swing.JLabel;
//import javax.swing.JFrame;
//import javax.swing.JList; // necesario para la JList
//import javax.swing.ListModel;
//import javax.swing.event.ListSelectionListener;
//import javax.swing.event.ListSelectionEvent;
//import javax.swing.ListSelectionModel;
//import javax.swing.JComboBox;
//import javax.swing.JTextField;
//import javax.swing.DefaultComboBoxModel;
//import javax.swing.JFrame;
//import javax.swing.JScrollPane;
//import java.lang.Integer;
// import java.awt.event.ActionEvent;
// import java.awt.event.ActionListener;
// import java.awt.event.ItemEvent;
// import java.awt.event.ItemListener;
// Para poder usar @Action
import skoa.models.VariableGlobal;
import org.jdesktop.application.Action;
import tuwien.auto.eibpoints.*;
import tuwien.auto.eibxlator.PointPDUXlator;
import tuwien.auto.eibxlator.PDUXlatorList;
import tuwien.auto.eicl.CEMI_Connection;
import tuwien.auto.eicl.struct.cemi.CEMI_L_DATA;
import tuwien.auto.eicl.util.*;
import tuwien.auto.eicl.struct.cemi.EIB_Address;

import java.util.Calendar; // necesaria para la fecha y hora del día
import java.text.SimpleDateFormat;
import java.util.Date;

import javax.swing.*; //para la clase textArea
import java.io.*; // necesaria para el manejo de ficheros

//Estefanía-->Para la actualización de la base de datos.
import skoa.bd.ActualizarBackup;
import skoa.bd.Crear;

/**
 *
 * @author  David
 */
public class LecturaPeriodica extends javax.swing.JDialog {
// Importado desde "Dialog_Read_Periodica.java"

    public static final long serialVersionUID = 1;
    private javax.swing.JButton b_Cancel;
    private javax.swing.JButton b_Desactivar;
    private javax.swing.JButton b_Activar;
    //private PointList pointList;
    private CEMI_Connection tunnel;
    private javax.swing.JList list_Point;
    private javax.swing.JScrollPane scroll_List;
    private javax.swing.JTextField tf_intervalo = new JTextField();
    private javax.swing.JTextField tf_intervalo_largo = new JTextField();
    private javax.swing.JTextField tf_fichero_contadores = new JTextField();
    private javax.swing.JLabel l_major_largo;
    private javax.swing.JLabel l_fichero_contadores;
    private javax.swing.JLabel l_muestreo_corto;
    public String ficheroLOG;
    private VariableGlobal VG;
    private javax.swing.JTextArea textArea;
    private String fecha_hora;
    // Para utilizarlo como tercer parámetro en la llamada a "LecturaPeriodica"
    //public static PointList Lcontadores = new PointList();
    // Declaramos 3 variables que actuarán como hilos
    // Para activar y desactivar la lectura periódica de los contadores
    // Y realizar una copia de seguridad del fichero con las medidas, respectivamente
    Th_ActivaEnvioPeriodico t1;
    Th_DesactivaEnvioPeriodico t2;
    Th_ActivaBackUp t3;

    /** Creates new form LecturaPeriodica */
    public LecturaPeriodica(java.awt.Frame parent, boolean modal,
            CEMI_Connection _Tunnel, String _fecha_hora, VariableGlobal _Activado,
            JTextArea _textArea, String _ficheroLOG, String _tf_fichero_contadores) {
        super(parent, modal);
        //pointList = _PointList;
        tunnel = _Tunnel;
        fecha_hora = _fecha_hora;
        VG = _Activado;
        textArea = _textArea;
        ficheroLOG = _ficheroLOG;
        tf_fichero_contadores.setText(_tf_fichero_contadores);
        //initComponents();
        initComponents_mio();
    }

    // Importado de "Dialog_Read_Periodica"
    // Proceso que obtiene los puntos insertados y los muestra en la lista
    private void repaintList() {
        // Obtiene una descripción con el nombre y dirección de todos los puntos contenidos en VariableGlobal.Lcontadores
        ListModel list_PointModel = new DefaultComboBoxModel(VariableGlobal.Lcontadores.getPointDescriptions());
        // Establece el modelo que representa los valores de la lista, notifica los cambios a los listeners
        // y limpia la selección de la lista
        list_Point.setModel(list_PointModel);
    }

    // Para cerrar la ventana al pulsar en "Cancelar"
    @Action
    public void cerrarLectPeriodica() {
        setVisible(false);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scroll_List = new javax.swing.JScrollPane();
        list_Point = new javax.swing.JList();
        l_muestreo_corto = new javax.swing.JLabel();
        tf_intervalo = new javax.swing.JTextField();
        l_major_largo = new javax.swing.JLabel();
        tf_intervalo_largo = new javax.swing.JTextField();
        l_fichero_contadores = new javax.swing.JLabel();
        tf_fichero_contadores = new javax.swing.JTextField();
        b_Activar = new javax.swing.JButton();
        b_Desactivar = new javax.swing.JButton();
        b_Cancel = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(skoa.views.SkoaApp.class).getContext().getResourceMap(LecturaPeriodica.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setName("Form"); // NOI18N
        setResizable(false);

        scroll_List.setName("scroll_List"); // NOI18N

        list_Point.setName("list_Point"); // NOI18N
        scroll_List.setViewportView(list_Point);

        l_muestreo_corto.setFont(resourceMap.getFont("l_muestreo_corto.font")); // NOI18N
        l_muestreo_corto.setText(resourceMap.getString("l_muestreo_corto.text")); // NOI18N
        l_muestreo_corto.setName("l_muestreo_corto"); // NOI18N

        tf_intervalo.setText(resourceMap.getString("tf_intervalo.text")); // NOI18N
        tf_intervalo.setName("tf_intervalo"); // NOI18N

        l_major_largo.setFont(resourceMap.getFont("l_major_largo.font")); // NOI18N
        l_major_largo.setText(resourceMap.getString("l_major_largo.text")); // NOI18N
        l_major_largo.setName("l_major_largo"); // NOI18N

        tf_intervalo_largo.setText(resourceMap.getString("tf_intervalo_largo.text")); // NOI18N
        tf_intervalo_largo.setName("tf_intervalo_largo"); // NOI18N

        l_fichero_contadores.setFont(resourceMap.getFont("l_fichero_contadores.font")); // NOI18N
        l_fichero_contadores.setText(resourceMap.getString("l_fichero_contadores.text")); // NOI18N
        l_fichero_contadores.setName("l_fichero_contadores"); // NOI18N

        tf_fichero_contadores.setFont(resourceMap.getFont("tf_fichero_contadores.font")); // NOI18N
        tf_fichero_contadores.setText(resourceMap.getString("tf_fichero_contadores.text")); // NOI18N
        tf_fichero_contadores.setName("tf_fichero_contadores"); // NOI18N

        b_Activar.setFont(resourceMap.getFont("b_Activar.font")); // NOI18N
        b_Activar.setText(resourceMap.getString("b_Activar.text")); // NOI18N
        b_Activar.setName("b_Activar"); // NOI18N
        b_Activar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_ActivarActionPerformed(evt);
            }
        });

        b_Desactivar.setFont(resourceMap.getFont("b_Desactivar.font")); // NOI18N
        b_Desactivar.setText(resourceMap.getString("b_Desactivar.text")); // NOI18N
        b_Desactivar.setName("b_Desactivar"); // NOI18N
        b_Desactivar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_DesactivarActionPerformed(evt);
            }
        });

        javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(skoa.views.SkoaApp.class).getContext().getActionMap(LecturaPeriodica.class, this);
        b_Cancel.setAction(actionMap.get("cerrarLectPeriodica")); // NOI18N
        b_Cancel.setFont(resourceMap.getFont("b_Cancel.font")); // NOI18N
        b_Cancel.setText(resourceMap.getString("b_Cancel.text")); // NOI18N
        b_Cancel.setName("b_Cancel"); // NOI18N
        b_Cancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_CancelActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(scroll_List, javax.swing.GroupLayout.DEFAULT_SIZE, 305, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(l_muestreo_corto)
                            .addComponent(l_major_largo))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 18, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(tf_intervalo_largo, 0, 0, Short.MAX_VALUE)
                            .addComponent(tf_intervalo, javax.swing.GroupLayout.DEFAULT_SIZE, 53, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(b_Activar)
                        .addGap(36, 36, 36)
                        .addComponent(b_Desactivar)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 36, Short.MAX_VALUE)
                        .addComponent(b_Cancel))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(l_fichero_contadores)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(tf_fichero_contadores, javax.swing.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(scroll_List, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(l_muestreo_corto)
                    .addComponent(tf_intervalo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(l_major_largo)
                    .addComponent(tf_intervalo_largo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(l_fichero_contadores)
                    .addComponent(tf_fichero_contadores, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 40, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(b_Activar)
                    .addComponent(b_Cancel)
                    .addComponent(b_Desactivar))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

private void b_ActivarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_ActivarActionPerformed
    try {
        // Creamos el fichero de medidas (si hay información previa, la borra)
        PrintWriter writer = new PrintWriter(tf_fichero_contadores.getText());
        // Y cerramos el descriptor del mismo
        writer.close();
    } // Posibles excepciones
    catch (IOException ex) {
        new IOException(ex.getMessage());
    }

    // Activamos la variable que indica que se está realizando una lectura periódica
    VariableGlobal.lectura_manual = 1;
    // Y reinciamos el buffer por si se hubieran realizado lecturas manuales anteriormente
    // Ya que dicho buffer va almacenando los valores de los contadores que se van leyendo
    SkoaMain.b = "";

    // LLamamos al procedimiento que se encargará de ejecutar los hilos de lectura periódica
    ActivarActionPerformedPrevio(evt);

    // Obtenemos en un vector todos los puntos/contadores insertados
    Point[] p = VariableGlobal.Lcontadores.getAllPoints();

    // Número de iteraciones bucle = número de contadores
    for (int i = 0; i < p.length; i++) {
        // Retardo entre una medida de contador y otra (2 segundos)
        EsperaRato(2);

        if (i != 0 & SkoaMain.contadores_aparecidos == i - 1) {
            // Muestra el mensaje a través del LOG de los contadores y lo escribe en el fichero de LOG
            synchronized (SkoaMain.textArea2) {
                SkoaMain.textArea2.append(this.fecha_hora() + ": Esperamos 20 segundos a ver si aparece el contador \n");
                escribeMensajeLog(ficheroLOG, fecha_hora() + ": Esperamos 20 segundos a ver si aparece el contador \n");
            }
            EsperaRato(20);

            // Esto es en caso de que el contador anterior no haya llegado
            if (i != 0 & SkoaMain.contadores_aparecidos == i - 1) {
                i--;
            }
        }

        if (i == 0 & SkoaMain.contadores_aparecidos == p.length) {
            // Procedimiento análogo al anterior
            synchronized (SkoaMain.textArea2) {
                SkoaMain.textArea2.append(this.fecha_hora() + ": Esperamos 20 segundos a ver si aparece el contador \n");
                escribeMensajeLog(ficheroLOG, fecha_hora() + ": Esperamos 20 segundos a ver si aparece el contador \n");
            }
            EsperaRato(20);

            if (i == 0 & SkoaMain.contadores_aparecidos == p.length) // Esto es en caso de que el contador anterior no haya llegado
            {
                i = p.length - 1;
            }
        }

        //System.out.println(fecha_hora() + ": Contadores aparecidos= " + MaipezView.contadores_aparecidos +
        //        ", Solicitud Contador Num.= " + i); // mensaje por el terminal
        try {
            PointPDUXlator xlator = PDUXlatorList.getPointPDUXlator(p[i].getMajorType(), p[i].getMinorType());
            xlator.setServiceType(PointPDUXlator.A_GROUPVALUE_READ);
            CEMI_L_DATA data = new CEMI_L_DATA((byte) CEMI_L_DATA.MC_L_DATAREQ, new EIB_Address(),
                    p[i].getDeviceAddress()[0], xlator.getAPDUByteArray());
            tunnel.sendFrame(data, CEMI_Connection.WAIT_FOR_CONFIRM);


            // Se muestra información a través del log de los contadores
            synchronized (SkoaMain.textArea2) {
                /* ------------------ ESTO NO LO MOSTRARÉ ------------------------------------
                MaipezView.textArea2.append(this.fecha_hora() + ": MedidasLeídas=" + 
                MaipezView.contadores_aparecidos +
                ", OrdenNº " + i + ", " +
                //p[i].getDeviceName() + ")\n");
                p[i].getDeviceName() + "=");
                ------------------ ESTO NO LO MOSTRARÉ ------------------------------------ */

                // La siguiente linea permite que el textArea2 siempre muestre el envío del último contador
                // esto no es necesario para el textArea (no sé por qué)
                // source: http://java.sun.com/docs/books/tutorial/uiswing/components/textarea.html
                SkoaMain.textArea2.setCaretPosition(SkoaMain.textArea2.getDocument().getLength());

                // Escribimos el siguiente mensaje en el fichero LOG de la aplicación
                //escribeMensajeLog(ficheroLOG, fecha_hora() + ": Contadores aparecidos= " + 
                //      MaipezView.contadores_aparecidos +
                //    ", Solicitud de lectura periódica enviada a contador número " + i + " (" +
                escribeMensajeLog(ficheroLOG, fecha_hora() + ": Solicitud de lectura periódica enviada a contador número " + i + " ("
                        + p[i].getDeviceName() + ") \n");
            }
        } catch (EICLException ex) {
            SkoaMain.showException("Error en LecturaPeriodica.java > b_ActivarActionPerformed: "
                    + ex.getMessage());
        }
        // Espera 2 segundos para enviar la solicitud del siguiente contador
        EsperaRato(2);
    }
}//GEN-LAST:event_b_ActivarActionPerformed

// Es prácticamente igual que el procedimiento "b_ActivarActionPerformed", con algunas salvedades
// Necesario para ser ejectuado desde uno de los hilos (el encargado del envío periódico)
    public void b_ActivarActionPerformed_2(Integer intervalo) {
        // Activamos la variable que indica que se está realizando una lectura periódica
        VariableGlobal.lectura_manual = 1;

        // Obtenemos en un vector todos los puntos/contadores insertados
        Point[] p = VariableGlobal.Lcontadores.getAllPoints();

        // Número de iteraciones bucle = número de contadores
        for (int i = 0; i < p.length; i++) {
            // Retardo entre una medida de contador y otra (2 segundos)
            EsperaRato(2);

            if (i != 0 & SkoaMain.contadores_aparecidos == i - 1) {
                // Muestra el mensaje a través del LOG de los contadores y lo escribe en el fichero de LOG
                synchronized (SkoaMain.textArea2) {
                    SkoaMain.textArea2.append(this.fecha_hora() + ": Esperamos 20 segundos a ver si aparece el contador \n");
                    escribeMensajeLog(ficheroLOG, fecha_hora() + ": Esperamos 20 segundos a ver si aparece el contador \n");
                }
                EsperaRato(20);

                // Esto es en caso de que el contador anterior no haya llegado
                if (i != 0 & SkoaMain.contadores_aparecidos == i - 1) {
                    i--;
                }
            }

            if (i == 0 & SkoaMain.contadores_aparecidos == p.length) {
                // Procedimiento análogo al anterior
                synchronized (SkoaMain.textArea2) {
                    SkoaMain.textArea2.append(this.fecha_hora() + ": Esperamos 20 segundos a ver si aparece el contador \n");
                    escribeMensajeLog(ficheroLOG, fecha_hora() + ": Esperamos 20 segundos a ver si aparece el contador \n");
                }
                EsperaRato(20);

                if (i == 0 & SkoaMain.contadores_aparecidos == p.length) // Esto es en caso de que el contador anterior no haya llegado
                {
                    i = p.length - 1;
                }
            }

            //System.out.println(fecha_hora() + ": Contadores aparecidos= " + MaipezView.contadores_aparecidos +
            //        ", Solicitud Contador Num.= " + i); // mensaje por el terminal
            try {
                PointPDUXlator xlator = PDUXlatorList.getPointPDUXlator(p[i].getMajorType(), p[i].getMinorType());
                xlator.setServiceType(PointPDUXlator.A_GROUPVALUE_READ);
                CEMI_L_DATA data = new CEMI_L_DATA((byte) CEMI_L_DATA.MC_L_DATAREQ, new EIB_Address(),
                        p[i].getDeviceAddress()[0], xlator.getAPDUByteArray());
                tunnel.sendFrame(data, CEMI_Connection.WAIT_FOR_CONFIRM);

                // Se muestra información a través del log de los contadores
                synchronized (SkoaMain.textArea2) {
                    /* ------------------ ESTO NO LO MOSTRARÉ ------------------------------------
                    MaipezView.textArea2.append(this.fecha_hora() + ": MedidasLeídas=" + 
                    MaipezView.contadores_aparecidos +
                    ", OrdenNº " + i + ", " +
                    //p[i].getDeviceName() + ")\n");
                    p[i].getDeviceName() + "=");
                    ------------------ ESTO NO LO MOSTRARÉ ------------------------------------ */

                    // La siguiente linea permite que el textArea2 siempre muestre el envío del último contador
                    // esto no es necesario para el textArea (no sé por qué)
                    // source: http://java.sun.com/docs/books/tutorial/uiswing/components/textarea.html
                    SkoaMain.textArea2.setCaretPosition(SkoaMain.textArea2.getDocument().getLength());

                    // Escribimos el siguiente mensaje en el fichero LOG de la aplicación
                    // escribeMensajeLog(ficheroLOG, fecha_hora() + ": Contadores aparecidos= " + 
                    // MaipezView.contadores_aparecidos +
                    // ", Solicitud de lectura periódica enviada a contador número " + i + " (" +
                    escribeMensajeLog(ficheroLOG, fecha_hora() + ": Solicitud de lectura periódica enviada a contador número " + i + " ("
                            + p[i].getDeviceName() + ") \n");
                }
            } catch (EICLException ex) {
                SkoaMain.showException("Error en LecturaPeriodica.java > b_ActivarActionPerformed: "
                        + ex.getMessage());
            }
            // Espera 2 segundos para enviar la solicitud del siguiente contador
            EsperaRato(2);
        }
    }

private void b_DesactivarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_DesactivarActionPerformed
    // "this" es la clase principal que mantiene el contenido de la variable global "Activado"
    t2 = new Th_DesactivaEnvioPeriodico(this);

    // Mostramos en el log de la aplicación que se ha ejecutado el hilo encargado de desactiva la lectura periódica
    synchronized (textArea) {
        SkoaMain.textArea.append(fecha_hora() + ": Hilo h2 ejecutado: Lectura periódica de contadores desactivada\n");
    }
    t2.start(); // lanza el hilo de activación periódico "Th_ActivaEnvioPeriodico"
    this.dispose();
}//GEN-LAST:event_b_DesactivarActionPerformed

private void b_CancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_CancelActionPerformed
    this.dispose();
}//GEN-LAST:event_b_CancelActionPerformed

    public void ActivarActionPerformedPrevio(java.awt.event.ActionEvent evt) {
        // Obtenemos los intevalos corto y largo en dos variables
        Integer intervalo = Integer.valueOf(tf_intervalo.getText()).intValue();
        Integer intervalo_largo = Integer.valueOf(tf_intervalo_largo.getText()).intValue();
        //String fichero_contadores = tf_fichero_contadores.getText();
        // Y el fichero en el que se almacenarán las medidas de los contadores
        String fichero_contadores = SkoaMain.Fmedidas_MCA_cnf;

        // Activa la variable global y desbloquea a los hilos bloqueados por wait()
        this.putActivado("on");

        // Muestra en el Log de la aplicación el siguiente mensaje:
        synchronized (textArea) {
            textArea.append(fecha_hora() + ": Lectura periódica solicitada. Parámetros introducidos: intervalo de muestreo corto= " + intervalo
                    + " (minutos), intervalo de muestreo largo= " + intervalo_largo
                    + " (horas), fichero con las medidas de los contadores= " + fichero_contadores + "\n");

            // El mensaje también se escribe en el fichero Log
            escribeMensajeLog(ficheroLOG, fecha_hora()
                    + ": Lectura periódica solicitada. Parámetros introducidos: intervalo de muestreo corto= " + intervalo
                    + " (minutos), intervalo de muestreo largo= " + intervalo_largo
                    + " (horas), fichero con las medidas de los contadores= " + fichero_contadores + "\n");
        }

        // "this" es la clase principal que mantiene el contenido de la variable global "Activado"
        t1 = new Th_ActivaEnvioPeriodico(intervalo, this);
        // Lanza el hilo de activación periódico "Th_ActivaEnvioPeriodico"
        t1.start();
        // E informa de ello en el log de la apliacación
        synchronized (textArea) {
            SkoaMain.textArea.append(fecha_hora() + ": Se ha ejecutado el Hilo h1: lectura periódica de contadores (cada " + intervalo + " minutos) \n");
            escribeMensajeLog(ficheroLOG, fecha_hora() + ": Se ha ejecutado el Hilo h1: lectura periódica de contadores (cada " + intervalo + " minutos) \n");
        }

        // "this" es la clase principal que mantiene el contenido de la variable global "Activado"
        t3 = new Th_ActivaBackUp(intervalo_largo, this, textArea, fichero_contadores);
        // Lanza el Hilo de activación periódico "Th_ActivaBackUp"
        t3.start();
        // E informa de ello en el log de la aplicación
        synchronized (textArea) {
            SkoaMain.textArea.append(fecha_hora() + ": Se ha ejecutado el Hilo h3: copia de seguridad(backup) del fichero con las medidas de los contadores (cada " + intervalo_largo + " horas) \n");
            escribeMensajeLog(ficheroLOG, fecha_hora() + ": Se ha ejecutado el Hilo h3: copia de seguridad(backup) del fichero con las medidas de los contadores (cada " + intervalo_largo + " horas) \n");
        }

        // Para hacer desaparecer la ventana de diálogo
        this.dispose();
    }

    public void escribeMensajeLog(String _ficheroLOG, String _mensajeLog) {
        try {
            // Abrimos el FICHERO DE ACCESO ALEATORIO en cada escritura a la ventana MainFrame
            RandomAccessFile miRAFile = new RandomAccessFile(_ficheroLOG, "rw");
            // Nos vamos al final del fichero
            miRAFile.seek(miRAFile.length());
            // Incorporamos un mensaje obtenido del bus KNX al fichero miRAFile    
            miRAFile.writeBytes(_mensajeLog);
            // Cerramos el fichero
            miRAFile.close();
        } catch (IOException ex) {
            new IOException(ex.getMessage());
        }
    }

    private void EsperaRato(int Rato) {
        try {    // Espera "Rato" segundos, ya que el parámetro de wait se mide en milisegundos
            synchronized (this) {
                wait(Rato * 1000);
            }
        } catch (Exception ex) { // catch necesario para el wait
            SkoaMain.showException(ex.getMessage());
        }
    }

    public String getLOG() {
        return tf_fichero_contadores.getText();
    }

// Esta quizás no haga falta pq yo ya añado la ruta a través de la interfaz
    public void putLOG(String _fichero) {
        tf_fichero_contadores.setText(_fichero); // MIO: se añade una dirección fija siempre por defecto
        this.getContentPane().add(tf_fichero_contadores, null);
    }

    private void initComponents_mio() {
        scroll_List = new javax.swing.JScrollPane();
        list_Point = new javax.swing.JList();
        l_muestreo_corto = new javax.swing.JLabel();
        tf_intervalo = new javax.swing.JTextField();
        l_major_largo = new javax.swing.JLabel();
        tf_intervalo_largo = new javax.swing.JTextField();
        l_fichero_contadores = new javax.swing.JLabel();
        tf_fichero_contadores = new javax.swing.JTextField();
        b_Activar = new javax.swing.JButton();
        b_Desactivar = new javax.swing.JButton();
        b_Cancel = new javax.swing.JButton();
        // Importado de "Dialog_Read_Periodica.java"
        repaintList();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(skoa.views.SkoaApp.class).getContext().getResourceMap(LecturaPeriodica.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setName("Form"); // NOI18N
        setResizable(false);

        scroll_List.setName("scroll_List"); // NOI18N

        list_Point.setName("list_Point"); // NOI18N
        // Establecemos los contadores que se verán en la lista al abrir la ventana de "Lectura Periódica"
        scroll_List.setViewportView(list_Point);

        l_muestreo_corto.setFont(resourceMap.getFont("l_muestreo_corto.font")); // NOI18N
        l_muestreo_corto.setText(resourceMap.getString("l_muestreo_corto.text")); // NOI18N
        l_muestreo_corto.setName("l_muestreo_corto"); // NOI18N

        tf_intervalo.setText(resourceMap.getString("tf_intervalo.text")); // NOI18N
        tf_intervalo.setName("tf_intervalo"); // NOI18N

        l_major_largo.setFont(resourceMap.getFont("l_major_largo.font")); // NOI18N
        l_major_largo.setText(resourceMap.getString("l_major_largo.text")); // NOI18N
        l_major_largo.setName("l_major_largo"); // NOI18N

        tf_intervalo_largo.setText(resourceMap.getString("tf_intervalo_largo.text")); // NOI18N
        tf_intervalo_largo.setName("tf_intervalo_largo"); // NOI18N

        l_fichero_contadores.setFont(resourceMap.getFont("l_fichero_contadores.font")); // NOI18N
        l_fichero_contadores.setText(resourceMap.getString("l_fichero_contadores.text")); // NOI18N
        l_fichero_contadores.setName("l_fichero_contadores"); // NOI18N

        tf_fichero_contadores.setFont(resourceMap.getFont("tf_fichero_contadores.font")); // NOI18N
        tf_fichero_contadores.setText(resourceMap.getString("tf_fichero_contadores.text")); // NOI18N
        tf_fichero_contadores.setName("tf_fichero_contadores"); // NOI18N

        b_Activar.setFont(resourceMap.getFont("b_Activar.font")); // NOI18N
        b_Activar.setText(resourceMap.getString("b_Activar.text")); // NOI18N
        b_Activar.setName("b_Activar"); // NOI18N
        b_Activar.addActionListener(new java.awt.event.ActionListener() {

            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_ActivarActionPerformed(evt);
            }
        });

        b_Desactivar.setFont(resourceMap.getFont("b_Desactivar.font")); // NOI18N
        b_Desactivar.setText(resourceMap.getString("b_Desactivar.text")); // NOI18N
        b_Desactivar.setName("b_Desactivar"); // NOI18N
        b_Desactivar.addActionListener(new java.awt.event.ActionListener() {

            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_DesactivarActionPerformed(evt);
            }
        });

        javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(skoa.views.SkoaApp.class).getContext().getActionMap(LecturaPeriodica.class, this);
        b_Cancel.setAction(actionMap.get("cerrarLectPeriodica")); // NOI18N
        b_Cancel.setFont(resourceMap.getFont("b_Cancel.font")); // NOI18N
        b_Cancel.setText(resourceMap.getString("b_Cancel.text")); // NOI18N
        b_Cancel.setName("b_Cancel"); // NOI18N
        b_Cancel.addActionListener(new java.awt.event.ActionListener() {

            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_CancelActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(scroll_List, javax.swing.GroupLayout.DEFAULT_SIZE, 305, Short.MAX_VALUE).addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup().addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(l_muestreo_corto).addComponent(l_major_largo)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 18, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false).addComponent(tf_intervalo_largo, 0, 0, Short.MAX_VALUE).addComponent(tf_intervalo, javax.swing.GroupLayout.DEFAULT_SIZE, 53, Short.MAX_VALUE))).addGroup(layout.createSequentialGroup().addComponent(b_Activar).addGap(36, 36, 36).addComponent(b_Desactivar).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 36, Short.MAX_VALUE).addComponent(b_Cancel)).addGroup(layout.createSequentialGroup().addComponent(l_fichero_contadores).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent(tf_fichero_contadores, javax.swing.GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE))).addContainerGap()));
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addContainerGap().addComponent(scroll_List, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(l_muestreo_corto).addComponent(tf_intervalo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(l_major_largo).addComponent(tf_intervalo_largo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addGap(18, 18, 18).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(l_fichero_contadores).addComponent(tf_fichero_contadores, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)).addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 40, Short.MAX_VALUE).addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE).addComponent(b_Activar).addComponent(b_Cancel).addComponent(b_Desactivar)).addContainerGap()));

        pack();
    }

    // Función que proporciona una String con la fecha y hora actual
    public String fecha_hora() {
        Calendar calendario = Calendar.getInstance();
        String _fecha_hora = calendario.getInstance().getTime().toString();
        //MessageDialog md1 = new MessageDialog(
        //"Hora: " + _fecha_hora + "\n",MessageDialog.INFO_PIC);
        return _fecha_hora;
    }

    public synchronized String getActivado() {
        notifyAll();
        return VG.getVariable();
    }

    public synchronized void putActivado(String value) {
        String slocal = new String(VG.getVariable());
        slocal = value;
        VG.initVariable(slocal);
        notifyAll();
    }

    /**
     * @param args the command line arguments
     */
    public void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                LecturaPeriodica dialog = new LecturaPeriodica(new javax.swing.JFrame(),
                        true, tunnel, fecha_hora, VG, textArea,
                        ficheroLOG, tf_fichero_contadores.getText());
                dialog.addWindowListener(new java.awt.event.WindowAdapter() {

                    public void windowClosing(java.awt.event.WindowEvent e) {
//                        System.out.println("quiero salir en lectura periodica.java");
                        System.exit(0);
                    }
                });
                dialog.setVisible(true);
            }
        });
    }
    /*
     * public LecturaPeriodica(java.awt.Frame parent, boolean modal, PointList _PointList,
    CEMI_Connection _Tunnel, String _fecha_hora, VariableGlobal _Activado,
    JTextArea _textArea, String _ficheroLOG, String _tf_fichero_contadores)
     */

    /*
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton b_Activar;
    private javax.swing.JButton b_Cancel;
    private javax.swing.JButton b_Desactivar;
    private javax.swing.JLabel l_fichero_contadores;
    private javax.swing.JLabel l_major_largo;
    private javax.swing.JLabel l_muestreo_corto;
    private javax.swing.JList list_Point;
    private javax.swing.JScrollPane scroll_List;
    private javax.swing.JTextField tf_fichero_contadores;
    private javax.swing.JTextField tf_intervalo;
    private javax.swing.JTextField tf_intervalo_largo;
    // End of variables declaration//GEN-END:variables
     */
}

// Clases importadas de "Dialog_Read_Periodica.java"
// Esta clase representa a un hilo distinto para activar periódicamente la lectura de contadores
class Th_ActivaEnvioPeriodico extends Thread {

    private int retardo;
    private LecturaPeriodica Th1_DRP; // clase donde está la variable global
    private SimpleDateFormat formateador = new SimpleDateFormat("dd_MM_yyyy_HH_mm");

    // Constructor que inicializa variables locales de la clase
    public Th_ActivaEnvioPeriodico(int d, LecturaPeriodica _Activado) {
        retardo = d;         // Los minutos de retardo entre lectura y lectura
        Th1_DRP = _Activado; // La clase de la variable global
    }

    // El metodo run() es similar al main(), pero para threads
    // Cuando run() termina, el thread MUERE (finaliza su ejecución)
    public void run() {
        int i = 0, j;
        try {
            // Mostramos un mensaje de información en el log de los contadores
            synchronized (SkoaMain.textArea2) {
                // Si se descomenta la línea de abajo, la fecha saldría así: 10_03_2010_11_49 (por ej)
                // MaipezView.textArea2.append(formateador.format(new Date()) + ": Hilo h1 ACTIVADO " +
                SkoaMain.textArea2.append(Th1_DRP.fecha_hora() + ": Se ha ejecutado el Hilo h1: lectura "
                        + "periódica de contadores (cada " + retardo + " minutos) \n");

            }
            /* ----------------------------- NO ES NECESARIO --------------------------------------------
            // Y lo escribimos en el fichero log de la aplicación
            Th1_DRP.escribeMensajeLog(Th1_DRP.ficheroLOG, Th1_DRP.fecha_hora() + 
            ": Hilo h1 ACTIVADO para muestreo periódico cada " + retardo + " minutos\n");
            
            Ya informamos en el fichero log de la aplicación en "ActivarActionPerformedPrevio"
            ----------------------------- NO ES NECESARIO -------------------------------------------- */

            // Este while consulta la variable global de la clase "Th1_DRP"
            // que indica si el envío periódico está activado o no
            // También se asegura que no se haya pulsado el botón "Desconectar del bus EIB"
            while (Th1_DRP.getActivado().equals("on") && VariableGlobal.desconexion != 8) {
                i++;

                // Enviar solicitudes de lectura a contadores
                Th1_DRP.b_ActivarActionPerformed_2(retardo);

                // Retardo para lanzar la siguiente medida de contadores.
                // Está en milisegundos, se multiplica por 60*1000 para pasar a minutos
                // Se hace así y no con un simple "sleep( retardo*1000*60 );" porque
                // para intervalos de muestreo largos, si se quiere desactivar el muestreo en medio
                // de dicho intervalo, no se puede porque se está dentro de un thread.
                // De esta forma, con el while se sale del thread cada segundo
                j = 0;
                while (Th1_DRP.getActivado().equals("on") && j < retardo * 60) {
                    j++;
                    sleep(1000); // El retardo durará "retardo" minutos
                }
            }  // fin del primer while
        } catch (InterruptedException exp) {
            SkoaMain.showException(exp.getMessage());
        }
    } // Fin del procedimiento run(): Th_ActivaEnvioPeriodico
}

// Esta clase desactiva la lectura periódica de los contadores
class Th_DesactivaEnvioPeriodico extends Thread {

    private LecturaPeriodica Th2_DRP; // clase donde está la variable global

    public Th_DesactivaEnvioPeriodico(LecturaPeriodica _Activado) {
        Th2_DRP = _Activado; // la clase de la variable global
    }

    // El metodo run() es similar al main(), pero para hilos
    // Cuando run() termina, el hilo MUERE
    public void run() {
        Th2_DRP.putActivado("off"); // Desactiva la lectura periódica de contadores
        // Informamos en el fichero Log de la apliación de la desactivación de la lectura periódica
        Th2_DRP.escribeMensajeLog(Th2_DRP.ficheroLOG, Th2_DRP.fecha_hora()
                + ": Hilo h2 ejecutado: Lectura periódica de contadores desactivada \n");
    }
}

// Clase que representa a un hilo distinto para activar periódicamente la lectura de contadores
class Th_ActivaBackUp extends Thread {

    private int retardo_largo;
    private LecturaPeriodica Th1_DRP; // Clase donde está la varigable global
    private JTextArea textArea;
    private SimpleDateFormat formateador = new SimpleDateFormat("dd_MM_yyyy_HH_mm");
    private String fichero_contadores;

    public Th_ActivaBackUp(int d, LecturaPeriodica _Activado, JTextArea _textArea, String _fichero_contadores) {
        retardo_largo = d;
        Th1_DRP = _Activado; // La clase de la variable global
        textArea = _textArea;
        fichero_contadores = _fichero_contadores;
    }

    // El metodo run() es similar al main(), pero para
    // threads. Cuando run() termina el thread MUERE
    public void run() {
        int i = 0, j;
        Runtime r = Runtime.getRuntime();
        Process p = null, p1 = null;

        try {
            /* ------------------ NO ES NECESARIO ------------------------------------------
            // Informamos a través del log de la aplicación
            synchronized (textArea) {
            // textArea.append(formateador.format(new Date()) + ": Hilo h3 para " +
            textArea.append(Th1_DRP.fecha_hora() + ": Hilo h3 para " +
            "Backup ACTIVADO cada " + retardo_largo + " horas\n");
            }
            // Y escribimos la información en el fichero log de la aplicación
            Th1_DRP.escribeMensajeLog(Th1_DRP.ficheroLOG, Th1_DRP.fecha_hora() + 
            ": Hilo h3 ACTIVADO cada " + retardo_largo + " horas\n");
            
            Ya informamos de ello en "ActivarActionPerformedPrevio"
            ------------------ NO ES NECESARIO ------------------------------------------ */

            // Este while consulta la variable global de la clase "Th1_DRP"
            // que indica si el envío periódico está activado o no
            // También se asegura que no se haya pulsado el botón "Desconectar del bus EIB"
            while (Th1_DRP.getActivado().equals("on") && VariableGlobal.desconexion != 8) {
                i++;
                // Retardo para lanzar la siguiente medida de contadores. 
                // Está en milisegundos, se multiplica por 60*1000 para pasar a minutos
                // Se hace así y no con un simple "sleep( retardo*1000*60 );" porque
                // para intervalos de muestreo largos, si se quiere desactivar el muestre en medio
                // del intervalo, no se puede porque se está dentro de un hilo.
                // De esta forma, se sale del hilo cada segundo
                j = 0;

                while (Th1_DRP.getActivado().equals("on") && j < retardo_largo * 60 * 60) {
                    j++;
                    sleep(1000); // espera 1 segundo
                } // Se sale del while cuando pasan "retardo_largo" horas (1 hora = 60*60 segundos)
                sleep(20 * 1000); // Espera 20 segundos paraa realizar las operaciones con ficheros
                p = r.exec("cmd /c copy " + "\"" + fichero_contadores + "\""
                        + " " + "\"" + fichero_contadores + "_backup"
                        + formateador.format(new Date()) + ".log\"");

                // Se informa de la copia realizada a través del log de la aplicación
                synchronized (textArea) {
                    //textArea.append(formateador.format(new Date()) + ": Se ha copiado el fichero " + fichero_contadores + " en el fichero " +
                    textArea.append(Th1_DRP.fecha_hora() + ": Se ha copiado el fichero " + fichero_contadores + " en el fichero "
                            + fichero_contadores + "_backup" + formateador.format(new Date()) + ".log\n");
                }

                // También se escribe es información en el fichero log de la aplicación
                Th1_DRP.escribeMensajeLog(Th1_DRP.ficheroLOG, Th1_DRP.fecha_hora()
                        + ": Se ha copiado el fichero " + fichero_contadores + " en el fichero "
                        + fichero_contadores + "_backup" + formateador.format(new Date()) + ".log\n");

                //COPIAMOS EL FICHERO backup EN LA CARPETA Logs.
                File dir_inicial = new File("./");
                String ruta_jar = dir_inicial.getAbsolutePath(), carpeta, barra;
                String os = System.getProperty("os.name");
                if (os.indexOf("Win") >= 0) {    //En Windows las barras son \ y en Linux /.
                    carpeta = ruta_jar + "\\Logs";
                    barra = "\\";
                } else {
                    carpeta = ruta_jar + "/Logs";
                    barra = "/";
                }
                File carpetalogs = new File(carpeta);
                if (!carpetalogs.exists()) {
                    carpetalogs.mkdir();//Se crea el directorio si no existe
                }
                // Procedimiento análogo para el fichero LOG de la aplicación
                //COPIA EL FICHERO BACKUP EN LA MISMA CARPETA QUE DONDE ESTÁ Log_SKoA.log
                //LO DEJAMOS PARA COMPROBAR QUE SE HACE BIEN LA COPIA EN LA CARPETA LOGS
            /*p = r.exec( "cmd /c copy " + "\"" + Th1_DRP.ficheroLOG + "\"" +
                " " + "\"" + Th1_DRP.ficheroLOG + "_backup" + 
                formateador.format(new Date()) + ".log\"" );
                 */
                //COPIA EL FICHERO LOG BACKUP EN LA CARPETA Logs
                System.out.println("Th1_DRP.ficheroLOG contiene=" + Th1_DRP.ficheroLOG);
                p = r.exec("cmd /c copy " + "\"" + Th1_DRP.ficheroLOG + "\""
                        + " " + "\"" + carpeta + barra + Th1_DRP.ficheroLOG + "_backup"
                        + formateador.format(new Date()) + ".log\"");
                //Coger sólo lo que nos interese de Th1_DRP.ficheroLOG para añadirle nosotros la ruta.
                String ficheroAClasificar = carpeta + barra + Th1_DRP.ficheroLOG + "_backup" + formateador.format(new Date()) + ".log";
                //---------------------------------------------------------------------
                synchronized (textArea) {
                    //textArea.append(formateador.format(new Date()) + ": Se ha copiado el fichero " 
                    textArea.append(Th1_DRP.fecha_hora() + ": Se ha copiado el fichero "
                            + Th1_DRP.ficheroLOG + " en el fichero " + Th1_DRP.ficheroLOG + "_backup"
                            + formateador.format(new Date()) + ".log\n");
                }

                Th1_DRP.escribeMensajeLog(Th1_DRP.ficheroLOG, Th1_DRP.fecha_hora()
                        + ": Se ha copiado el fichero " + Th1_DRP.ficheroLOG + " en el fichero "
                        + Th1_DRP.ficheroLOG + "_backup" + formateador.format(new Date()) + ".log\n");

                // Se informa a través del log de la aplicación que se han reiniciado los ficheros correspondientes
                // al log de la aplicacion y al de las medidas de los contadores
                synchronized (textArea) {
                    //textArea.append(formateador.format(new Date()) + ": Se ha reiniciado el fichero " + fichero_contadores + "\n");
                    textArea.append(Th1_DRP.fecha_hora() + ": Se ha reiniciado el fichero " + fichero_contadores + "\n");
                }
                Th1_DRP.escribeMensajeLog(Th1_DRP.ficheroLOG, Th1_DRP.fecha_hora()
                        + ": Se ha reiniciado el fichero " + fichero_contadores + "\n");

                synchronized (textArea) {
                    //textArea.append(formateador.format(new Date()) + ": Se ha reiniciado el fichero " + Th1_DRP.ficheroLOG + "\n");
                    textArea.append(Th1_DRP.fecha_hora() + ": Se ha reiniciado el fichero " + Th1_DRP.ficheroLOG + "\n");
                }
                Th1_DRP.escribeMensajeLog(Th1_DRP.ficheroLOG, Th1_DRP.fecha_hora()
                        + ": Se ha reiniciado el fichero " + Th1_DRP.ficheroLOG + "\n");

                sleep(20 * 1000); // Espera 20 segundos a realizar las operaciones con ficheros

                //ACTUALIZO LA BASE DE DATOS.
                Thread bd, act;     //Hilos de actualizacion y creacion de la BD
                bd = new Crear();
                bd.run();
                while (bd.isAlive()) {
                }
                sleep(10 * 1000); // Espera 10 segundos para usar el fichero para actualizar la BD.
                System.out.println("Fichero a clasificar=" + ficheroAClasificar);
                //act=new NuevoActualizar();
                act = new ActualizarBackup(ficheroAClasificar);
                act.run();
                //---------------------------
                p1 = r.exec("cmd /c del " + "\"" + fichero_contadores + "\"");

                p1 = r.exec("cmd /c del " + "\"" + Th1_DRP.ficheroLOG + "\"");

                // Log de la actividad de la aplicación
                synchronized (textArea) {
                    // La siguiente linea limpia la ventana principal del texto mostrado en el último intervalo largo
                    // se hace para probar a ver si se disminuye el requerimiento de memoria heap y no causa el error "out of memory"
                    //textArea.replaceRange(formateador.format(new Date()) + ": Se ha inicializado " +
                    textArea.replaceRange(Th1_DRP.fecha_hora() + ": Se ha inicializado "
                            + "la ventana \n", 0, textArea.getText().length());
                    //textArea.append(formateador.format(new Date()) +
                    textArea.append(Th1_DRP.fecha_hora()
                            + ": Se ha copiado el fichero " + fichero_contadores + " en " + fichero_contadores + "_backup"
                            + formateador.format(new Date()) + ".log\n");

                    //textArea.append(formateador.format(new Date()) + 
                    textArea.append(Th1_DRP.fecha_hora()
                            + ": Se ha copiado el fichero " + Th1_DRP.ficheroLOG + " en "
                            + Th1_DRP.ficheroLOG + "_backup" + formateador.format(new Date()) + ".log\n");

                    //textArea.append(formateador.format(new Date()) + ": Se ha reiniciado el fichero " + fichero_contadores + "\n" );
                    textArea.append(Th1_DRP.fecha_hora() + ": Se ha reiniciado el fichero " + fichero_contadores + "\n");
                    //textArea.append(formateador.format(new Date()) + ": Se ha reiniciado el fichero " + Th1_DRP.ficheroLOG + "\n" );
                    textArea.append(Th1_DRP.fecha_hora() + ": Se ha reiniciado el fichero " + Th1_DRP.ficheroLOG + "\n");
                }

                // Log de la actividad de los contadores
                synchronized (SkoaMain.textArea2) {
                    //MaipezView.textArea2.replaceRange(formateador.format(new Date()) + ": Se ha inicializado " +
                    SkoaMain.textArea2.replaceRange(Th1_DRP.fecha_hora() + ": Se ha inicializado "
                            + "la ventana \n", 0, SkoaMain.textArea2.getText().length());
                }
            } // fin del while que comprueba si está activo el envío periódico
        } catch (InterruptedException exp) {
            SkoaMain.showException(exp.getMessage());
        } catch (Exception e) {
            synchronized (textArea) {
                textArea.append(formateador.format(new Date()) + ": Error ejecutando la copia del fichero\n");
            }
        }
    } // fin del procedimiento run(): Th_ActivaBackUp
} // fin de la clase "Th_ActivaBackUp"
