/**                   
 * 
 GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
 */


package skoa.views;


import skoa.models.VariableGlobal;
import skoa.models.MiFormato;
import tuwien.auto.eibpoints.*;
import tuwien.auto.eibxlator.*;
import tuwien.auto.eicl.struct.cemi.EIB_Address;
import tuwien.auto.eicl.util.*;
import java.awt.Dimension;
import java.awt.Toolkit;
import javax.swing.JOptionPane;
import javax.swing.JLabel;

/**
 *
 * @author  David
 */
public class InsertarActSen extends javax.swing.JDialog {
    
    //private PointList pointList; // La lista de contadores
    private String coord_x; // Coordenadas x e y del actuador/sensor que se va a insertar
    private String coord_y;
    private String planta;
    private String estancia;
    private String tipo;
    private int opcion;
    
    // Para utilizarlo como tercer parámetro en la llamada a "InsertarActSen"
    public static PointList Lcontadores = new PointList();

    /** Creates new form InsertarActSen */
    public InsertarActSen(java.awt.Frame parent, boolean modal, String x, String y, String pla, String est, String type, int op) {
        super(parent, modal);
        //pointList = _PointList;
        coord_x = x;
        coord_y = y;
        planta = pla;
        estancia = est;
        tipo = type;
        opcion = op;
        initComponents();
        initComponents_mio();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLTipo = new javax.swing.JLabel();
        jLSubtipo = new javax.swing.JLabel();
        jLDirgrupo = new javax.swing.JLabel();
        jCBTipo = new javax.swing.JComboBox();
        jCBSubtipo = new javax.swing.JComboBox();
        jTFDirgrupo = new javax.swing.JTextField();
        jBAceptar = new javax.swing.JButton();
        jBCancelar = new javax.swing.JButton();
        jLNombre = new javax.swing.JLabel();
        jTFNombre = new javax.swing.JTextField();

        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance().getContext().getResourceMap(InsertarActSen.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setName("Form"); // NOI18N
        setResizable(false);

        jLTipo.setFont(resourceMap.getFont("jLTipo.font")); // NOI18N
        jLTipo.setText(resourceMap.getString("jLTipo.text")); // NOI18N
        jLTipo.setName("jLTipo"); // NOI18N

        jLSubtipo.setFont(resourceMap.getFont("jLSubtipo.font")); // NOI18N
        jLSubtipo.setText(resourceMap.getString("jLSubtipo.text")); // NOI18N
        jLSubtipo.setName("jLSubtipo"); // NOI18N

        jLDirgrupo.setFont(resourceMap.getFont("jLDirgrupo.font")); // NOI18N
        jLDirgrupo.setText(resourceMap.getString("jLDirgrupo.text")); // NOI18N
        jLDirgrupo.setName("jLDirgrupo"); // NOI18N

        jCBTipo.setFont(resourceMap.getFont("jCBTipo.font")); // NOI18N
        jCBTipo.setName("jCBTipo"); // NOI18N

        jCBSubtipo.setFont(resourceMap.getFont("jCBSubtipo.font")); // NOI18N
        jCBSubtipo.setName("jCBSubtipo"); // NOI18N

        jTFDirgrupo.setFont(resourceMap.getFont("jTFDirgrupo.font")); // NOI18N
        jTFDirgrupo.setText(resourceMap.getString("jTFDirgrupo.text")); // NOI18N
        jTFDirgrupo.setName("jTFDirgrupo"); // NOI18N

        jBAceptar.setFont(resourceMap.getFont("jBAceptar.font")); // NOI18N
        jBAceptar.setText(resourceMap.getString("jBAceptar.text")); // NOI18N
        jBAceptar.setName("jBAceptar"); // NOI18N
        jBAceptar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBAceptarActionPerformed(evt);
            }
        });

        jBCancelar.setFont(resourceMap.getFont("jBCancelar.font")); // NOI18N
        jBCancelar.setText(resourceMap.getString("jBCancelar.text")); // NOI18N
        jBCancelar.setName("jBCancelar"); // NOI18N
        jBCancelar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBCancelarActionPerformed(evt);
            }
        });

        jLNombre.setFont(resourceMap.getFont("jLNombre.font")); // NOI18N
        jLNombre.setText(resourceMap.getString("jLNombre.text")); // NOI18N
        jLNombre.setName("jLNombre"); // NOI18N

        jTFNombre.setText(resourceMap.getString("jTFNombre.text")); // NOI18N
        jTFNombre.setName("jTFNombre"); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLTipo)
                            .addComponent(jLSubtipo)
                            .addComponent(jLNombre))
                        .addGap(31, 31, 31)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTFNombre, javax.swing.GroupLayout.DEFAULT_SIZE, 174, Short.MAX_VALUE)
                            .addComponent(jCBSubtipo, 0, 174, Short.MAX_VALUE)
                            .addComponent(jCBTipo, 0, 174, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLDirgrupo)
                        .addGap(20, 20, 20)
                        .addComponent(jTFDirgrupo, javax.swing.GroupLayout.DEFAULT_SIZE, 172, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(45, 45, 45)
                        .addComponent(jBAceptar)
                        .addGap(18, 18, 18)
                        .addComponent(jBCancelar)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLTipo)
                    .addComponent(jCBTipo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLSubtipo)
                    .addComponent(jCBSubtipo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(26, 26, 26)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLNombre)
                    .addComponent(jTFNombre, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLDirgrupo)
                    .addComponent(jTFDirgrupo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(39, 39, 39)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jBCancelar)
                    .addComponent(jBAceptar))
                .addContainerGap(26, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

private void jBAceptarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBAceptarActionPerformed
try {
        // Se comprueba que no haya previamente un dispositivo insertado con el mismo nombre
        Point[] vec_p = VariableGlobal.Lcontadores.getAllPoints();
        for (int i=0; i<vec_p.length; i++)
            if (vec_p[i].getDeviceName().indexOf(jTFNombre.getText()) != -1)
                {
                    String err = "Ya existe un contador con ese nombre. Escoga otro, por favor.";
                    JOptionPane.showMessageDialog(null, err, "Advertencia", 1);
                    return;
                }
        
                // Comprueba que los campos "nombre" y "dir. grupo" tengan información
                if (!jTFDirgrupo.getText().equals("") & !jTFNombre.getText().equals("") )
                {
                    if (jTFNombre.getText().length() > 6)
                    {
                        // El nombre no puede superar los 6 caracteres (limitación de Mide Cuando Arranca)
                        String err = "El nombre no puede superar los 6 caracteres. Escoga otro, por favor";
                        JOptionPane.showMessageDialog(null, err, "Advertencia", 1);
                    }
                    else
                    {
                        if (jTFNombre.getText().length() < 6){
                            String nombreseis = jTFNombre.getText();
                            while(nombreseis.length() < 6){
                                nombreseis = "."+nombreseis;
                            }
                            jTFNombre.setText(nombreseis);
                        }
//System.out.println("nombre:"+jTFNombre.getText()+"------Longitud:"+jTFNombre.getText().length());--------------------------------------------------------------!!!!!
                        // Obtiene la dirección de grupo
                        EIB_Address eib = new EIB_Address(jTFDirgrupo.getText());
                        // Obtiene el tipo
                        String major = PDUXlatorList.getPointTypeMajor_mio().getTypeKey(
                             (String) jCBTipo.getSelectedItem());
                        // Y el subtipo
                        String minor = PDUXlatorList.getPointPDUMinor_mio(major).getTypeKey(
                            (String) jCBSubtipo.getSelectedItem());
                        // Ya tenemos un nuevo punto, con su nombre, dirección EIB, tipo y subtipo
                        Point p = new Point(jTFNombre.getText(), eib, major, minor);
                        // Lo añadimos a la lista de puntos
                        VariableGlobal.Lcontadores.addPoint(p);

                        // Inma: crea una variable con la información acerca del actuador/sensor insertado
                        MiFormato aux = new MiFormato (jTFNombre.getText(), jTFDirgrupo.getText(), major, minor, coord_x, coord_y);
                        
//                        System.out.println("nombre dispositivo:"+jTFNombre.getText());

                        DispositivoNuevo.parametros.add(aux);
                        // Inma: añade el icono al plano
                        JLabel insertar = new JLabel();
                        insertar.setName(DragMouseAdapter.nombreLabel);
                        insertar.setIcon(DispositivoNuevo.iconito);
                        insertar.setBounds(Integer.parseInt(coord_x),Integer.parseInt(coord_y), 50, 60);
                        DispositivoNuevo.panel_plano.add(insertar, javax.swing.JLayeredPane.DRAG_LAYER);
                        
                        // Comprobamos si la pareja planta-estancia no está insertada en el vector vecDispUsados
                        // Si no lo está, la insertamos
                        if (SkoaMain.comprueba_planta_estancia(DispositivoNuevo.planta_seleccionada, DispositivoNuevo.estancia_seleccionada) == 0)
                        {
                            // Insertamos el nombre de la planta
                            SkoaMain.vecDispUsados[VariableGlobal.indVDispUsad] = DispositivoNuevo.planta_seleccionada;
                            VariableGlobal.indVDispUsad++;
                            // El nombre de la estancia
                            SkoaMain.vecDispUsados[VariableGlobal.indVDispUsad] = DispositivoNuevo.estancia_seleccionada;
                            // E incrementamos 11 posiciones debido a la estancia y los 10 contadores que posee cada estancia
                            VariableGlobal.indVDispUsad = VariableGlobal.indVDispUsad + 11; 
                        }

                        // Obtenemos el índice que indica donde comienzan los contadores de la estancia que estamos tratando
                        int pos = SkoaMain.devuelve_pos(DispositivoNuevo.planta_seleccionada, DispositivoNuevo.estancia_seleccionada);
                        int numero = 0;
                        
                        // Ahora que ya sabemos el tipo y la posición en el vector donde comienzan los contadores, 
                        // tan solo nos queda acceder al vector y ver qué número de elemento es el que se está añadiendo
                        // Por ej: tipo=luz regulable, posición=3(para acceder al vector), número=4(valor obtenido por el vector, significa que es la 4ª luz que se añade a la estancia)
                        switch(opcion)
                        {
                            // Accedemos al vector, incrementamos en uno el contador, y actualizamos dicho vector
                            case 1:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos]);
                                numero++;
                                SkoaMain.vecDispUsados[pos] = String.valueOf(numero);
                                break;
                            // Mismo procedimiento para cada caso, teniendo en cuenta que la posición del vector se incrementa en uno
                            case 2:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+1]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+1] = String.valueOf(numero);
                                break;
                                
                            case 3:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+2]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+2] = String.valueOf(numero);
                                break;
                                
                            case 4:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+3]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+3] = String.valueOf(numero);
                                break;
                                
                            case 5:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+4]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+4] = String.valueOf(numero);
                                break;
                                
                            case 6:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+5]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+5] = String.valueOf(numero);
                                break;
                                
                            case 7:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+6]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+6] = String.valueOf(numero);
                                break;
                                
                            case 8:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+7]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+7] = String.valueOf(numero);
                                break;
                                
                            case 9:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+8]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+8] = String.valueOf(numero);
                                break;
                                
                            case 10:
                                numero = Integer.valueOf(SkoaMain.vecDispUsados[pos+9]);
                                numero++;
                                SkoaMain.vecDispUsados[pos+9] = String.valueOf(numero);
                                break;
                        }
                        
                        // Añadimos al vector vecDispDomoticos la información del elemento insertado
                        // Es decir: planta, estancia, tipo, numero y nombre
                        SkoaMain.vecDispDomoticos[VariableGlobal.indVDispDom] = planta;
                        SkoaMain.vecDispDomoticos[VariableGlobal.indVDispDom+1] = estancia;
                        SkoaMain.vecDispDomoticos[VariableGlobal.indVDispDom+2] = tipo;
                        SkoaMain.vecDispDomoticos[VariableGlobal.indVDispDom+3] = Integer.toString(numero);
                        SkoaMain.vecDispDomoticos[VariableGlobal.indVDispDom+4] = jTFNombre.getText();
                        VariableGlobal.indVDispDom = VariableGlobal.indVDispDom+5;
                        
                        // Cerramos la ventana
                        this.dispose();
                    }
                }
                else
                {
                    // En caso de que falte alguna información, se advierte de ello al usuario
                    String error = "Rellene todos los campos, por favor";
                    JOptionPane.showMessageDialog(null, error, "Advertencia", 1);
                }
                
        } catch (EICLException ex) {
            SkoaMain.showException(ex.getMessage());
        }
}//GEN-LAST:event_jBAceptarActionPerformed

private void jBCancelarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBCancelarActionPerformed
    this.dispose();
}//GEN-LAST:event_jBCancelarActionPerformed

    private void initComponents_mio()
    {
        // Importado de "Dialog_Point_mio.java"
        // Obtiene todos los tipos posibles
        String[] help = PDUXlatorList.getPointTypeMajor_mio().getAllTypeDescription();
        for (int i=0; i<help.length; i++)
            // Y los añade al combobox del tipo
            jCBTipo.addItem(help[i]);
        // Por defecto, no aparecerá ningún elemento seleccionado del combobox
        jCBTipo.setSelectedIndex(-1);
        
        jCBTipo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCBTipoActionPerformed(evt);
            }
        });
    }
    
// Acción llevada a cabo cuando se pulsa sobre el combobox del tipo
private void jCBTipoActionPerformed(java.awt.event.ActionEvent evt) {                                        
    // Elimina todos los elementos del combobox subtipo
    jCBSubtipo.removeAllItems();
        String[] s = new String[0];
            try {
                // Obtiene el tipo seleccionado en el combobox y lo pasa a String
                String help = PDUXlatorList.getPointTypeMajor().getTypeKey(
                        jCBTipo.getSelectedItem().toString());
                // Obtiene los subtipos pertenecientes al tipo anterior
                s = PDUXlatorList.getPointPDUMinor(help).getAllTypeDescription();
            } catch (EICLException ex) {
                // En caso de que se produzca una excepción
                SkoaMain.showException(ex.getMessage());
            }
        
        // Se añaden los elementos necesarios al combobox subtipo
        for (int i=0; i<s.length; i++)
            jCBSubtipo.addItem(s[i]);
        // Y se activa dicho combobox, permitiendo al usuario elegir uno
        jCBSubtipo.setEnabled(true);
}
    
    /**
    * @param args the command line arguments
    */
    public static void main(final String x, final String y, final String planta, final String estancia, final String tipo, final int opc) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                InsertarActSen dialog = new InsertarActSen(new javax.swing.JFrame(), true, x, y, planta, estancia, tipo, opc);
                // Para centrar la ventana
                Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
                Dimension frameSize = dialog.getSize();
                if (frameSize.height > screenSize.height) {
                    frameSize.height = screenSize.height;
                }
                if (frameSize.width > screenSize.width) {
                    frameSize.width = screenSize.width;
                }
                dialog.setLocation((screenSize.width - frameSize.width) / 2,
                        (screenSize.height - frameSize.height) / 2);
                dialog.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jBAceptar;
    private javax.swing.JButton jBCancelar;
    private javax.swing.JComboBox jCBSubtipo;
    private javax.swing.JComboBox jCBTipo;
    private javax.swing.JLabel jLDirgrupo;
    private javax.swing.JLabel jLNombre;
    private javax.swing.JLabel jLSubtipo;
    private javax.swing.JLabel jLTipo;
    private javax.swing.JTextField jTFDirgrupo;
    private javax.swing.JTextField jTFNombre;
    // End of variables declaration//GEN-END:variables

}
